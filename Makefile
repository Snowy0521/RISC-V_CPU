# Makefile for RISC-V CPU Simulation
# This Makefile automates the process of building and simulating a RISC-V CPU.
# It takes a firmware program written in C and assembly, compiles it, links it, and then uses Verilator to build and run a C++ simulation of the CPU, generating a waveform file for analysis.

# Variables and Paths
TARGET = firmware # Defines the project name as firmaware
VMLINUX = obj/${TARGET}.elf # Sets the variable VMLINUX to obj/${TARGET}.elf, which will be the output file for the compiled firmare in ELF (Executable and Linkable Fommat) format
VMEM = bin/${TARGET}.img # Sets the variable VMEM to bin/${TARGET}.img, which is the binary image file used by the Verilator simulation
VMLINUX_DIR = ${dir ${VMLINUX}} # Uses the dir function to extract the directory path from VMLINUX, setting VMLINUX_DIR to obj/
VMEM_DIR = ${dir ${VMEM}} # Sets VMEM_DIR to bin/

# Toolchain
RISCV_CC = riscv32-unknown-elf-gcc # Specifies the RISC-V GCC compiler
RISCV_OBJCOPY = riscv32-unknown-elf-objcopy # Defines the objcopy tool for converting ELF files to binary 
RISCV_OBJDUMP = riscv32-unknown-elf-objdump # Defines the objdump tool for disassembling ELF files


# Sources
FIRMWARE_ASM = firmware/start.s # Points to the assembly startup file
FIRMWARE_C = firmware/main.c # Points to the main C source file
LINKER_SCRIPT = firmware/link.ld # Points to the linker script, which defines the memory layout 

# Verilator 
VERILATOR = verilator # Invorkes the Verilator tool 
VERILATOR_FLAGS = -Wall --cc --exe --trace --trace-structs -02 # Enables all warnings (-Wall), generates C++ code (--cc), compiles the C++ testbench (--exe), enables waveform tracing (--trace), and optimizes the generated code (-O2)
TOP_MODULE = top # Defines the name of the top module in the Verilog design
CPP_SOURCES = sim/top.cpp: # Specifies the C++ file that acts as the testbench for the simulation

# Targets
all: sim.vcd # Specifies that when run the commmand 'make' without any arguments, it will build the simulation waveform file sim.vcd

# Build the firmware
# -nostdlib: Tells the compiler not to use the standard library, as this firmware is likely running on bare metal
# -T ${LINKER_SCRIPT}: Uses the specified linker script to control memory layout
# -o ${VMLINUX}: Specifies the output file for the compiled ELF firmware
# -D disassembles all sections
# > redirects the output to a human-readable list file (.lst), which is very useful for debugging and verifying the generated machine code. 
${VMLINUX}: ${FIRMWARE_ASM} ${FIRMWARE_C} ${LINKER_SCRIPT} # firmware.elf will be rebuilt if any of the source files or the linker script change
	mkdir -p ${VMLINUX_DIR} 
	${RISCV_CC} ${FIRMWARE_ASM} ${FIRMWARE_C} \ 
		-nostdlib -T ${LINKER_SCRIPT} -o ${VMLINUX} 
	${RISCV_OBJDUMP} -D ${VMLINUX} > ${VMLINUX}.lst

# Generating the Memory Image
# Converts the firmware ELF file into a raw binary file (tmp.bin), which is just the machine code and data without any headers or metadata.
# dd (data definition): utilizes to create a file named zero.pad
# if=/dev/zero: specifies that the input file is /dev/zero, which is a special file that provides as many null bytes as needed.
# of=${VMEM_DIR}/zero.pad: specifies the output file where the null bytes will be written.
# bs=1: sets the block size to 1 byte, meaning that each read and write operation will handle one byte at a time.
# count=8192: specifies that 8192 bytes (8 KB) of zero bytes should be written to the output file.
# 2>/dev/null: redirects any error messages to /dev/null (black hole), keeping the terminal output clean.
# cat ... |: concatenates the temporary binary file and the zero.pad file, creating a complete memory image, sending the output through a pipe (|)
# dd of=${VMEM}: writes the concatenated output to the final memory image file firmware.img, which will be used by the Verilator simulation.
${VMEM}: ${VMLINUX}
	mkdir -p ${VMEM_DIR}
	${RISCV_OBJCOPY} -0 binary ${VMLINUX} ${VMEM_DIR}/tmp.bin 
	dd if=/dev/zero of=${VMEM_DIR}/zero.pad bs=1 count=8192 2>/dev/null
	cat ${VMEM_DIR}/tmp.bin ${VMEM_DIR}/zero.pad | \ 
		dd of=${VMEM} bs=1 count=8192 2>/dev/null

# Compiling the Verilator Simulator
# make -C sim -f Vtop.mk: This command changes the directory to sim and runs the Makefile Vtop.mk, which is generated by Verilator. It compiles the C++ testbench and links it with the Verilog design files.
sim/Vtop: ${VMEM} src/*.v $(CPP_SOURCES)
	${VERILATOR} ${VERILATOR_FLAGS} ${CPP_SOURCES} \
		--top-module cpu \
		--Mdir sim \
		src/cpu.v src/register_file.v src/alu.v src/memory.v 
	make -C sim -f Vtop.mk

# Running the Simulation
sim.vcd: sim/Vtop
	sim/Vtop 

# Open the waveform file in GTKWave
wave: 
	gtkwave sim.vcd

# Clean up generated files
clean:
	rm -rf obj/ bin/ sim/ *.vcd *.log 

# The list of targets are not actual files to be created, but rather commands to be executed.
.PHONY: all clean wave